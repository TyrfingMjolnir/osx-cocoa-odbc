//
//  AppDelegate.m
//  Library1
//
//  Created by Mikael Hakman on 2013-10-04.
//  Copyright (c) 2013 Mikael Hakman. All rights reserved.
//

#import "AppDelegate.h"

NSString * PersistentStoreType;
NSString * PersistentStoreClass;
NSURL    * PersistentStoreUrl;
NSString * DraggedAuthorsType;
NSString * DraggedBooksType;

@interface AppDelegate ()

@property (nonatomic) NSURL * persistentStoreUrl;

@end

@implementation AppDelegate

@synthesize persistentStoreCoordinator = _persistentStoreCoordinator;
@synthesize managedObjectModel = _managedObjectModel;
@synthesize managedObjectContext = _managedObjectContext;

@synthesize persistentStoreUrl;

+ (void) initialize {
    
    PersistentStoreType = @"OdbcStore";
    
    PersistentStoreClass = @"OdbcStore";
    
    PersistentStoreUrl = [NSURL URLWithString : @"odbc:///newdb?username=root"];

    DraggedAuthorsType = @"library.authors";
    
    DraggedBooksType = @"library.books";
    
    if (PersistentStoreClass != nil) {
    
        [NSPersistentStoreCoordinator registerStoreClass : NSClassFromString (PersistentStoreClass)
                                            forStoreType : PersistentStoreType];
    }
}

- (void) applicationDidFinishLaunching : (NSNotification *) aNotification {
    
    [self setUpSortDescriptors];
    
    [self setUpNotifications];
}

- (void) setUpNotifications {
    
    NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];
    
    [nc addObserver : self selector : @selector (objectsDidChange:)
               name : NSManagedObjectContextObjectsDidChangeNotification
             object : self.managedObjectContext];
}

- (void) objectsDidChange : (NSNotification *) notification {
    
    [self.commitChangesButton setEnabled : YES];
}

- (void) setUpSortDescriptors {
    
    NSSortDescriptor * titleSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"title" ascending : YES selector : @selector (localizedCompare:)];
    
    self.booksSortDescriptors = @[titleSort];
    
    NSSortDescriptor * firstNameSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"firstName" ascending : YES selector : @selector (localizedCompare:)];
    
    NSSortDescriptor * lastNameSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"lastName" ascending : YES selector : @selector (localizedCompare:)];
    
    self.authorsSortDescriptors = @[lastNameSort,firstNameSort];
}

- (NSURL *) persistentStoreUrl {
    
    if (PersistentStoreUrl) return PersistentStoreUrl;
    
    NSString * productName = [self productName];
        
    NSString * storeFileName = [NSString stringWithFormat:@"%@.storedata",productName];
    
    NSURL * url = [self.applicationFilesDirectory URLByAppendingPathComponent : storeFileName];
    
    return url;
}

- (NSString *) productName {
    
    NSDictionary * bundleInfo = [[NSBundle mainBundle] infoDictionary];
    
    NSString * productName = [bundleInfo objectForKey : @"CFBundleName"];
    
    return productName;
}

- (void) presentErrorAlert : (NSError *) error {
    
    NSString * errorName = error.domain;
    
    NSString * errorDesc = [error.userInfo objectForKey : NSLocalizedDescriptionKey];
    
    if (! errorDesc) {
    
        errorDesc = [error.userInfo objectForKey : @"Description"];
    }
    
    [self presentCriticalAlert : errorName info : errorDesc];
}

- (void) presentCriticalAlert : (NSString *) error info : (NSString *) info {
    
    NSAlert * alert = [NSAlert new];
    
    [alert addButtonWithTitle : @"OK"];
    
    [alert setMessageText : error];
    
    [alert setInformativeText : info];
    
    [alert setAlertStyle : NSCriticalAlertStyle];
    
    NSWindow * window = ((NSApplication *) NSApp).keyWindow;
    
    [alert beginSheetModalForWindow : window
                      modalDelegate : self
                     didEndSelector : nil
                        contextInfo : nil];
}

//
//------------------------------------------------------------------------------
// Code below has been generated by XCode
//
// I have modified the code in few places in order to easily change store type
// and in order to avoid hard coding of some constants and parameters. Instead
// you can modify the constants in the initialize method.
//------------------------------------------------------------------------------
//
// Returns the directory the application uses to store the Core Data store file.
//
- (NSURL *) applicationFilesDirectory {
    
    NSFileManager * fileManager = [NSFileManager defaultManager];
    
    NSURL * appSupportURL =
    
    [[fileManager URLsForDirectory : NSApplicationSupportDirectory inDomains : NSUserDomainMask] lastObject];
    //
    // Using bundle identifier instead of a constant as it was in Xcode generated code
    //
    return [appSupportURL URLByAppendingPathComponent : [[NSBundle mainBundle] bundleIdentifier]];
}
//
// Creates if necessary and returns the managed object model for the application.
//
- (NSManagedObjectModel *)managedObjectModel {
    
    if (_managedObjectModel) return _managedObjectModel;
    //
    // Using bundle info instead of a constant as it was in XCode generated code
    //
    NSString * modelFileName = [self productName];
	
    NSURL * modelURL = [[NSBundle mainBundle] URLForResource : modelFileName withExtension : @"momd"];
    
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL : modelURL];
    
    return _managedObjectModel;
}

// Returns the persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it. (The directory for the store is created, if necessary.)
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{
    if (_persistentStoreCoordinator) {
        return _persistentStoreCoordinator;
    }
    
    NSManagedObjectModel *mom = [self managedObjectModel];
    if (!mom) {
        NSLog(@"%@:%@ No model to generate a store from", [self class], NSStringFromSelector(_cmd));
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSURL *applicationFilesDirectory = [self applicationFilesDirectory];
    NSError *error = nil;
    
    NSDictionary *properties = [applicationFilesDirectory resourceValuesForKeys:@[NSURLIsDirectoryKey] error:&error];
    
    if (!properties) {
        BOOL ok = NO;
        if ([error code] == NSFileReadNoSuchFileError) {
            ok = [fileManager createDirectoryAtPath:[applicationFilesDirectory path] withIntermediateDirectories:YES attributes:nil error:&error];
        }
        //
        // Using own error presentation instead of generated by XCode
        //
        if (! ok) {
            
            [self presentErrorAlert:error];

            return nil;
        }
    } else {
        if (![properties[NSURLIsDirectoryKey] boolValue]) {
            // Customize and localize this error.
            NSString *failureDescription = [NSString stringWithFormat:@"Expected a folder to store application data, found a file (%@).", [applicationFilesDirectory path]];
            
            NSMutableDictionary *dict = [NSMutableDictionary dictionary];
            [dict setValue:failureDescription forKey:NSLocalizedDescriptionKey];
            error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:101 userInfo:dict];
            
            [[NSApplication sharedApplication] presentError:error];
            return nil;
        }
    }
    //
    // Using a method to get URL instead of a constant as it was in XCode generated code
    //
    NSURL * url = self.persistentStoreUrl;
    
    NSPersistentStoreCoordinator * coordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel : mom];
    //
    // Using global variable StoreType instead of a constant as it was in XCode generated code
    //
    if (! [coordinator addPersistentStoreWithType : PersistentStoreType
                                    configuration : nil
                                              URL : url
                                          options : nil
                                            error : &error]) {
        //
        // Using own error presentation instead of generated by XCode
        //
        [self presentErrorAlert : error];                
    }
    
    _persistentStoreCoordinator = coordinator;
    
    return _persistentStoreCoordinator;
}

// Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) 
- (NSManagedObjectContext *)managedObjectContext
{
    if (_managedObjectContext) {
        return _managedObjectContext;
    }
    
    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
    if (!coordinator) {
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        [dict setValue:@"Failed to initialize the store" forKey:NSLocalizedDescriptionKey];
        [dict setValue:@"There was an error building up the data file." forKey:NSLocalizedFailureReasonErrorKey];
        NSError *error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];
        [[NSApplication sharedApplication] presentError:error];
        return nil;
    }
    _managedObjectContext = [[NSManagedObjectContext alloc] init];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];

    return _managedObjectContext;
}

// Returns the NSUndoManager for the application. In this case, the manager returned is that of the managed object context for the application.
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window
{
    return [[self managedObjectContext] undoManager];
}

// Performs the save action for the application, which is to send the save: message to the application's managed object context. Any encountered errors are presented to the user.
- (IBAction)saveAction:(id)sender
{
    NSError *error = nil;
    
    if (![[self managedObjectContext] commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing before saving", [self class], NSStringFromSelector(_cmd));
    }
    
    if (! [[self managedObjectContext] save : &error]) {
        //
        // Using own error presentation instead of generated by Xcode
        //
        [self presentErrorAlert : error];
    }
    //
    // Added disable commitChangesButton
    //
    [self.commitChangesButton setEnabled : NO];
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
{
    // Save changes in the application's managed object context before the application terminates.
    
    if (!_managedObjectContext) {
        return NSTerminateNow;
    }
    
    if (![[self managedObjectContext] commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing to terminate", [self class], NSStringFromSelector(_cmd));
        return NSTerminateCancel;
    }
    
    if (![[self managedObjectContext] hasChanges]) {
        return NSTerminateNow;
    }
    
    NSError *error = nil;
    if (![[self managedObjectContext] save:&error]) {

        // Customize this code block to include application-specific recovery steps.              
        BOOL result = [sender presentError:error];
        if (result) {
            return NSTerminateCancel;
        }

        NSString *question = NSLocalizedString(@"Could not save changes while quitting. Quit anyway?", @"Quit without saves error question message");
        NSString *info = NSLocalizedString(@"Quitting now will lose any changes you have made since the last successful save", @"Quit without saves error question info");
        NSString *quitButton = NSLocalizedString(@"Quit anyway", @"Quit anyway button title");
        NSString *cancelButton = NSLocalizedString(@"Cancel", @"Cancel button title");
        NSAlert *alert = [[NSAlert alloc] init];
        [alert setMessageText:question];
        [alert setInformativeText:info];
        [alert addButtonWithTitle:quitButton];
        [alert addButtonWithTitle:cancelButton];

        NSInteger answer = [alert runModal];
        
        if (answer == NSAlertAlternateReturn) {
            return NSTerminateCancel;
        }
    }

    return NSTerminateNow;
}

@end
