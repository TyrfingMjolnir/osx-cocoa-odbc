//
//  AppDelegate.m
//  Library1
//
//  Created by Mikael Hakman on 2013-10-04.
//  Copyright (c) 2013 Mikael Hakman. All rights reserved.
//

#import "AppDelegate.h"

NSString * PersistentStoreType;
NSString * PersistentStoreClass;
NSURL    * PersistentStoreUrl;
NSString * DraggedAuthorsType;
NSString * DraggedBooksType;

@interface AppDelegate ()

@property (nonatomic) NSURL                        * persistentStoreUrl;
@property (nonatomic) NSPersistentStoreCoordinator * persistentStoreCoordinator;
@property (nonatomic) NSManagedObjectModel         * managedObjectModel;
@property (nonatomic) NSManagedObjectContext       * managedObjectContext;

@end

@implementation AppDelegate

@synthesize window;
@synthesize persistentStoreCoordinator;
@synthesize managedObjectModel;
@synthesize managedObjectContext;

@synthesize persistentStoreUrl;

+ (void) initialize {
    
    PersistentStoreType = @"OdbcStore";
    
    PersistentStoreClass = @"OdbcStore";
    
    PersistentStoreUrl = [NSURL URLWithString : @"odbc:///newdb?username=root"];

    DraggedAuthorsType = @"library.authors";
    
    DraggedBooksType = @"library.books";
    
    if (PersistentStoreClass != nil) {
    
        [NSPersistentStoreCoordinator registerStoreClass : NSClassFromString (PersistentStoreClass)
                                            forStoreType : PersistentStoreType];
    }
}

- (void) applicationDidFinishLaunching : (NSNotification *) aNotification {
    
    [self setUpSortDescriptors];
    
    [self setUpNotifications];
}

- (void) setUpNotifications {
    
    NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];
    
    [nc addObserver : self selector : @selector (objectsDidChange:)
               name : NSManagedObjectContextObjectsDidChangeNotification
             object : self.managedObjectContext];
}

- (void) objectsDidChange : (NSNotification *) notification {
    
    [self.commitChangesButton setEnabled : YES];
}

- (void) setUpSortDescriptors {
    
    NSSortDescriptor * titleSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"title" ascending : YES selector : @selector (localizedCompare:)];
    
    self.booksSortDescriptors = @[titleSort];
    
    NSSortDescriptor * firstNameSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"firstName" ascending : YES selector : @selector (localizedCompare:)];
    
    NSSortDescriptor * lastNameSort =
    
    [NSSortDescriptor sortDescriptorWithKey : @"lastName" ascending : YES selector : @selector (localizedCompare:)];
    
    self.authorsSortDescriptors = @[lastNameSort,firstNameSort];
}

- (NSURL *) persistentStoreUrl {
    
    if (PersistentStoreUrl) return PersistentStoreUrl;
    
    NSString * productName = [self productName];
        
    NSString * storeFileName = [NSString stringWithFormat : @"%@.storedata",productName];
    
    NSURL * url = [self.applicationFilesDirectory URLByAppendingPathComponent : storeFileName];
    
    return url;
}

- (NSString *) productName {
    
    NSDictionary * bundleInfo = [[NSBundle mainBundle] infoDictionary];
    
    NSString * productName = [bundleInfo objectForKey : @"CFBundleName"];
    
    return productName;
}

- (IBAction) reloadData : (id) sender {
    
    NSSet * objects = self.managedObjectContext.registeredObjects;
    
    for (NSManagedObject * object in objects) {
        
        [self.managedObjectContext refreshObject : object mergeChanges : YES];
    }
}
//
//------------------------------------------------------------------------------
// Code below has been generated by XCode and modified by me.
//------------------------------------------------------------------------------
//
// Returns the managed object context for the application.
//
- (NSManagedObjectContext *) managedObjectContext {
    
    if (self->managedObjectContext) return self->managedObjectContext;
    
    NSPersistentStoreCoordinator * coordinator = [self persistentStoreCoordinator];
    
    self->managedObjectContext = [NSManagedObjectContext new];
                                  
    [self->managedObjectContext setPersistentStoreCoordinator : coordinator];
    
    [self->managedObjectContext setStalenessInterval : 0.0];
    
    return self->managedObjectContext;
}
//
// Returns the persistent store coordinator for the application.
//
- (NSPersistentStoreCoordinator *) persistentStoreCoordinator {
    
    if (self->persistentStoreCoordinator) return self->persistentStoreCoordinator;
    //
    // Get managed object model
    //
    NSManagedObjectModel * mom = [self managedObjectModel];
        
    NSError * error = nil;
    //
    // Using a method to get URL instead of a constant as it was in XCode generated code
    //
    NSURL * url = self.persistentStoreUrl;
    
    NSPersistentStoreCoordinator * coordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel : mom];
    //
    // Using global variable PersistentStoreType instead of a constant as it was in XCode generated code
    //
    if (! [coordinator addPersistentStoreWithType : PersistentStoreType
                                    configuration : nil
                                              URL : url
                                          options : nil
                                            error : &error]) {
        
        [[NSApplication sharedApplication] presentError : error];
        
        [[NSApplication sharedApplication] terminate : self];
        
        return nil;
    }
    
    self->persistentStoreCoordinator = coordinator;
    
    return self->persistentStoreCoordinator;
}
//
// Creates if necessary and returns the managed object model for the application.
//
- (NSManagedObjectModel *) managedObjectModel {
    
    if (self->managedObjectModel) return self->managedObjectModel;
    //
    // Using bundle info instead of a constant as it was in XCode generated code
    //
    NSString * modelFileName = [self productName];
	
    NSURL * modelURL = [[NSBundle mainBundle] URLForResource : modelFileName withExtension : @"momd"];
    
    self->managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL : modelURL];
    
    if (! self->managedObjectModel) {
        
        NSString * desc = [NSString stringWithFormat : @"Cannot create managed object model from url '%@'",modelURL];
        
        NSDictionary * dict = @{NSLocalizedDescriptionKey : desc};
        
        NSError * error = [NSError errorWithDomain : @"Managed Object Model" code : 0 userInfo : dict];
                
        [[NSApplication sharedApplication] presentError : error];
                
        [[NSApplication sharedApplication] terminate : self];
        
        return nil;
    }
    
    return self->managedObjectModel;
}
//
// Returns the directory the application uses to store the Core Data store file.
//
// Note that this method is not used when running against 'OdbcStore'.
//
- (NSURL *) applicationFilesDirectory {
    
    NSFileManager * fileManager = [NSFileManager defaultManager];
    
    NSURL * appSupportURL =
    
    [[fileManager URLsForDirectory : NSApplicationSupportDirectory inDomains : NSUserDomainMask] lastObject];

    NSError * error = nil;
    //
    // Get NSUrlIsDirectoryKey property for the url
    //
    NSDictionary * properties = [appSupportURL resourceValuesForKeys : @[NSURLIsDirectoryKey] error : &error];
    //
    // Check if we got any properties
    //
    if (!properties) {
        //
        // We did not - check if path exsists
        //
        if ([error code] == NSFileReadNoSuchFileError) {
            //
            // It does not - try to create the directory
            //
            bool ok = [fileManager createDirectoryAtPath : [appSupportURL path]
                             withIntermediateDirectories : YES
                                              attributes : nil
                                                   error : &error];
            
            if (! ok) {
                //
                // Could not create directory
                //
                [[NSApplication sharedApplication] presentError : error];
                
                [[NSApplication sharedApplication] terminate : self];
                
                return nil;
            }
            
        } else {
            //
            // It was some other error
            //            
            [[NSApplication sharedApplication] presentError : error];
            
            [[NSApplication sharedApplication] terminate : self];
            
            return nil;
        }
        
    } else {
        //
        // Check if url is directory
        //
        if (! [properties[NSURLIsDirectoryKey] boolValue]) {
            //
            // No it is not
            //
            NSString * failureDescription =
            
            [NSString stringWithFormat : @"Expected a folder to store application data, found a file (%@).",
                                         [appSupportURL path]];
            
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setValue : failureDescription forKey : NSLocalizedDescriptionKey];
            
            error = [NSError errorWithDomain : @"Applcation Support Directory" code : 101 userInfo : dict];
            
            [[NSApplication sharedApplication] presentError : error];
            
            [[NSApplication sharedApplication] terminate : self];
            
            return nil;
        }
    }
        
    return appSupportURL;
}
//
// Returns the NSUndoManager for the application.
//
- (NSUndoManager *) windowWillReturnUndoManager : (NSWindow *) window {

    return [[self managedObjectContext] undoManager];
}
//
// Performs the save action for the application.
//
- (IBAction) saveAction : (id) sender {
    
    NSError * error = nil;    
    //
    // Added disable commitChangesButton
    //
    [self.commitChangesButton setEnabled : NO];
    
    if (! self->managedObjectModel) return;
    
    if (! [[self managedObjectContext] commitEditing]) {
        
        error = [NSError errorWithDomain : @"Commit Editing"
                                    code : 0
                                userInfo : @{NSLocalizedDescriptionKey : @"Cannot commit editing"}];
        
        [[NSApplication sharedApplication] presentError : error];

        [[NSApplication sharedApplication] terminate : self];
        
        return;
    }
    
    if (! [[self managedObjectContext] hasChanges]) return;
    
    if (! [[self managedObjectContext] save : &error]) {

        [[NSApplication sharedApplication] presentError : error];
        
        [[NSApplication sharedApplication] terminate : self];
        
        return;
    }
}
//
// Called when application is about to terminate
//
- (NSApplicationTerminateReply) applicationShouldTerminate : (NSApplication *) sender {
    //
    // Save changes in the application's managed object context before the application terminates.
    //        
    [self saveAction : self];
    
    return NSTerminateNow;
}

@end
